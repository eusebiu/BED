---
title: "BED: a Biological Entity Dictionary based on a graph data model"
author: 
  - name: Patrice Godard
    affiliation: Corresponding author. Clarivate Analytics, 5901 Priestly Drive, 200, Carlsbad, CA 92008, USA. UCB Pharma, Chemin du Foriest, 1420 Braine-l'Alleud, Belgium patrice.godard@ucb.com.
  - name: Jonathan van Eyll
    affiliation: UCB Pharma, Chemin du Foriest, 1420 Braine-l'Alleud, Belgium jonathan.vaneyll@ucb.com.
abstract: The understanding of molecular processes involved in
   a specific biological system can be significantly improved by combining
   and comparing different data set and knowledge resources.
   However these information sources often use different
   identification systems and an identifier conversion step is required
   before any integration effort. Mapping between identifiers is often provided
   by the reference information resources
   and several tools have been implemented
   to simplify their use.
   However, the way the mapping is done by most of these tools cannot be
   customized, optimized or extended  by the user according to his knowledge
   or to internal, non-public or non-standard information.
   Also the information provided by different
   resources is not combined to increase the efficiency of the mapping process
   and deprecated identifiers from former version of databases are not taken
   into account. Finally finding automatically the most relevant path to
   map identifiers from one scope to the other is often not trivial.
   The Biological Entity Dictionary (BED) addresses these challenges by
   relying on a graph data model describing possible
   relationships between entities and their identifiers.
   This model has been implemented using Neo4j and an R
   package provides functions to query the graph but also to create and feed
   a custom instance of the database.
   This design combined with a local installation of the graph database and
   a cache sytem make BED very efficient to convert large lists of identifiers.
keywords: genomics, transcriptomics, proteomics, RNA-seq, microarray,
   database, identifiers.
bibliography: BED-References.bib
natbiboptions: round
output: BiocWorkflowTools::f1000_article
editor_options: 
  chunk_output_type: console
---

<!----------------------------------------------------------------------------->
<!-- Citations
<!---------------
[@Smith:2012qr].
Multiple entries with a semi-colon: [@Smith:2012qr; @Smith:2013jd].
The default bibliography style uses numerical citations. 
For superscript or author-year citations set the header
metadata field `natbiboptions` to either
`super` or `round`, respectively.
------------------------------------------------------------------------------->

```{r setup, include=FALSE}
reComp <- FALSE
library(knitr)
library(RColorBrewer)
library(VennDiagram)
library(gridExtra)
flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")
opts_chunk$set(
   include=FALSE,
   warning=FALSE, echo=FALSE, message=FALSE,
   concordance=TRUE
)
bigFormat <- function(x) {format(x, big.mark=",")}
library(BED)
connectToBed(url="localhost:5454", username="neo4j", password="1234")
```

\newcommand{\tm}{\textsuperscript{\textregistered}}
\newcommand{\neo}{Neo4j\tm{}}
\newcommand{\cypher}{Cypher\tm{}}
\newcommand{\docker}{Docker\tm{}}
\newcommand{\metabase}{MetaBase\tm{}}


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Introduction

Since the advent of genome sequencing projects, many technologies have been
developed to get access to different molecular information on a large scale
and with high throughput. DNA micro-arrays are probably the archetype of such
technology because of their historical impact on gathering data related
to nucleic acids: genomic DNA and RNA. They triggered the emergence of
"omics" fields of research such as genomics, epigenomics or transcriptomics.
Lately massive parallel sequencing
further increased the throughput of data generation related to nucleic acids
by several orders of magnitude.
In a different way, mass spectrometry-related technologies allow the
identification and the quantification of many kinds of molecular entities
such as metabolites and proteins.
Many information systems have been developped to manage
the exploding amount of data and knowledge related to biological
molecular entities.
These resources manage different aspects of
the data.
For example some are genome or proteome centered, whereas others
are focused on molecular interactions and pathways.
Thus all these resources rely on different identifier systems to organize
the concepts of interest.
The value of all the experimental data and all the knowledge
collected in public or private resources is very high as such
but is also often synergistically leveraged by their cross comparison
in a dedicated manner. Indeed many datasets can be relevant when
addressing the understanding of a specific biological system, a phenotypic trait
or a disease for example. These datasets can focus on different biological
entities such as transcripts or proteins in different tissues, conditions
or organisms. Comparing all these data and integrating them with
available knowledge requires the ability to map the identifiers on which
each resource relies.

To achieve this task public and proprietary information systems
provide mapping tables between their own identifiers and those
from other resources.
Furthermore many tools have been developed to facilitate the access
to this information.
Ensembl BioMarts [@kinsella_ensembl_2011],
mygene [@wu_biogps_2013],
and g:Profiler [@reimand_g:profiler-web_2016]
are popular examples among many others.
These resourses are convenient and easy to use with information
managed by their maintainers.
However, in general, this information cannot be customized, optimized
or extended by an enpowered user according to his knowledge or to internal,
non-public or non-standard data.
Recognizing these challenges @van_iersel_bridgedb_2010 proposed
the BridgeDb framework providing to bioinformatics developers
a standard interface between tools and
mapping services and also allowing the easy integration of custom data
by a transitivity mechanism.

Here we present BED: a biological entity dictionary.
BED has been developed to address three main challenges.
The first one is related to the completeness of identifier mappings.
Indeed direct mapping information provided by the different
systems are not always complete and can be enriched by mappings provided
by other resources. More interestingly direct mappings not identified by
any of these resources can be indirectly inferred by using mappings to a
third reference. For example, many human Ensembl gene identifiers are not
directly mapped to any Entrez gene identifiers but such mapping can be inferred
using respective mappings to HGNC identifiers.
The second challenge is related to the mapping of deprecated identifiers.
Indeed entity identifiers can change from one resource release to another.
The identifier history is provided by some resources, such as Ensembl or
the NCBI, but it is generally not used by mapping tools.
The third challenge is related to the automation of the mapping process
according to the relationships between the biological entities of interest.
Indeed mapping between gene and protein identifier scopes should not be done
the same way than two scopes of gene identifiers.
Also converting identifiers from different organism should be possible
using gene ortholog information.

To meet these challenges we designed a graph data model describing possible
relationships between different biological entities and their identifiers.
This data model has been implemented with the \neo{} graph
database [@neo4j_inc_neo4j_2017].
Graph databases are very efficient to implement biological data models.
They are more and more used in different fields of application.
For example, they are successfully used for
integrating various
pieces of knowledge [@pareja-tobes_bio4j:_2015 + @yoon_use_2017],
describing disease and phenotype relationships [@pareja-tobes_bio4j:_2015]
or modeling molecular networks
and pathways [@dai_hrgrn:_2016, @fabregat_reactome_2018-1].

In addition to the \neo{} graph database,
conversion rules have been defined and coded in
an R [@r_core_team_r:_2017] package. A particular attention has been put
on the efficiency of the tool by implementing a cache system making
recurrent queries fast.

Finally, we provide, for convenience, an instance of the BED database focused
on human, mouse and rat organisms. Nevertheless, many functions are available
in the R package to customize this instance or to construct other instances
tailored to other needs.

<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Methods

## Data model

```{r Data-Model, include=TRUE, out.width='100%', fig.cap = 'The BED graph data model. The model is shown as an Entity/Relationship (ER) diagram: entities correspond to graph nodes and relationships to graph edges. \`\`ID\'\' and \`\`idx\'\' indicate if the corresponding entity property is unique or indexed respectively. Some redundancies occur in this data model. Indeed some \`\`value\'\' properties are duplicated in upper case (\`\`value\\_up\'\') in order to improve the performance of case-insensitive searches. Also the database of a BEID node is provided as a property to ensure uniqueness of the couples of \`\`database\'\' and \`\`value\'\' properties. The same approach has been applied for the \`\`platform\'\' property of ProbeID nodes.'}
include_graphics('img/BED-Data-Model.pdf')
```

The BED (Biological Entity Dictionary) system relies on a data model
inspired by the central dogma of
molecular biology [@crick_central_1970] and describing
relationships between molecular concepts
usually manipulated in the frame of genomics studies
(Figure \@ref(fig:Data-Model)).
A biological entity identifier (*BEID*) can identify either a *Gene* (*GeneID*),
a *Transcript* (*TranscriptID*), a *Peptide* (*PeptideID*) or
an *Object* (*ObjectID*). *Object* entities can correspond to complex concepts
coded by any number of genes (i.e. a protein complex or a molecular function).
*BEID* are extracted from public or private databases (*BEDB*).
*BEDB* can provide an *Attribute* related to each *BEID*.
For example it can be the
sequencing region provided by the Ensembl database [@zerbino_ensembl_2017]
or the identifier
status provided by Uniprot [@the_uniprot_consortium_uniprot:_2017].
*BEID* can have one or several associated names (*BENames*) and symbols
(*BESymbol*). *GeneID* can have one or several homologs in other organisms
belonging to the same *GeneIDFamily*.
Many genomics platforms, such as micro-array, allow the identification of
biological entity by using probes identified by *ProbeID*. In general,
*BEID* can be targeted by several probes belonging to a *Platform* which
is focused on one, and only one, type of entity (BEType) among those described
above: *Gene*, *Transcript*, *Peptide* or *Object*.

According to this data model the scope of an identifier is defined by three
features:

   - its type: a BEType or Probe
   - its source: a database for BE identifiers
   or a platform for probe identifiers
   - the organism to which it refers

A BEType can have several
BEType products but can be the product of at most one BEType.
This constraint allows the unambiguous identification of the most relevant path
to convert identifiers from one scope to another and
is fulfilled by the current data model:
peptides are only produced from transcripts, which are only produced
from genes, which can also code for objects.

*BEID* identifying the same biological entity are related through three
different kinds of relationship according to the information available
in the source databases, and to the decision made by the database administrator
about how to use them. Two *BEID* which *corresponds_to* each other both
*identify* the same biological entity. A *BEID* which *is_associated_to* or
which *is_replaced_by* another *BEID* does not directly
identify any biological entity: the link is always indirect through
one or several other *BEID*. Therefore, by design a *BEID*
which *is_associated_to* or which *is_replaced_by* another *BEID* can be
related to several different biological entities. It is not the case for
other *BEID* which identify one and only one biological entity.
This set of possible relationship allows the indirect mapping of
different identifiers not necessarily provided by any integrated resource.

## Implementation

In order to efficiently leverage an indirect path through these different
relationships the data model has been implemented in
a \neo{} graph database [@neo4j_inc_neo4j_2017].

Two R [@r_core_team_r:_2017] packages have been developed to feed and query
the database.
The first one, neo2R, provides low level functions to interact with
\neo{}. The second R package, BED,
provides functions to feed and query the BED
\neo{} graph database according to the
data model described above.

## Feeding the database

Many functions are provided within the package to build a tailored BED database
instance. These functions are not exported in order not to mislead
the user when querying the database (which is the expected most frequent
usage of the system). An R markdown document showing how to build a BED database
instance for human, mouse and rat organisms is provided within the
package. It can be adapted to other organisms or needs.

Briefly these functions can be divided according to three main levels:

   - The lowest level function is the `bedImport` function
   which loads a table in the \neo{} database according to a \cypher{} query.
   
   - Functions of the second level allow loading identifiers and relationships
   tables ensuring the integrity of the data model:
   
      - `loadBE`, `loadProbes`, `loadOrganisms`, `loadBeAttribute`,
      `loadBEsymbols`, `loadBENames` and `loadBEVersion`
      are used to load information about BE and probes.
      
      - `loadHistory`, `loadCorrespondsTo`, `loadIsAssociatedTo`,
      `loadIsExpressedAs`,  `loadIsTranslatedIn`, `loadCodesFor`
      and `loadIsHomologOf`are used to load relationships existing
      between BEIDs and ProbeIDs.
      
   - Highest level functions are helpers for loading information provided by
   some public resources in different specific formats.
   The following resources are currently supported but other resources can
   be managed by the user by calling the function mentioned above.
      
      - Ensembl [@zerbino_ensembl_2017]:
      `getEnsemblGeneIds`, `getEnsemblTranscriptIds`, `getEnsemblPeptideIds`
      
      - NCBI[@ncbi_resource_coordinators_database_2017]:
      `loadNcbiTax`, `getNcbiGeneTransPep`, `loadNCBIEntrezGOFunctions`
      
      - Uniprot [@the_uniprot_consortium_uniprot:_2017]: `getUniprot`
      
      - Clarivate Analytics \metabase{} [@clarivate_analytics_metacore_2017]:
      `loadMBObjects`
      
## Available database instance

An instance of the BED database (UCB-Human)
has been built using the script provided
in the BED R package and made available in a \docker{}
image [@docker_inc_docker_2017] available here:
https://hub.docker.com/r/patzaw/bed-ucb-human/

This instance used to exemplify the following use cases
is focused on *Homo sapiens*, *Mus musculus* and *Rattus norvegicus* organisms
and it has been built from the following resources:

- Ensembl [@zerbino_ensembl_2017]
- NCBI [@ncbi_resource_coordinators_database_2017]
- Uniprot [@the_uniprot_consortium_uniprot:_2017]
- biomaRt [@durinck_mapping_2009]
- GEOquery [@davis_geoquery:_2007]
- Clarivate Analytics \metabase{} [@clarivate_analytics_metacore_2017]

```{r ID-Numbers, include=TRUE, results='asis'}
toShow <- c()
for(be in listBe()){
   for(org in BED::listOrganisms()){
      toAdd <- listBeIdSources(
         be=be,
         organism=org,
         exclude=c("BEDTech_gene", "BEDTech_transcript"),
         verbose=FALSE
      )
      colnames(toAdd) <- c("Database", "nbBE", "BEID", "BE")
      toAdd$Organism <- org
      toShow <- rbind(
         toShow,
         toAdd[,c("BE", "Organism", "Database", "BEID")]
      )
   }
}
urls <- c()
for(i in 1:nrow(toShow)){
   urls <- c(urls, getBeIdURL("", toShow[i, "Database"]))
}
urls <- substr(
   urls, start=1, stop=regexpr("[^/][/][^/].*$", urls)
)
# urls <- sub("^https*[:][/][/]", "", urls)
toShow$URL <- urls
kable(
   toShow,
   row.names=FALSE,
   format='pandoc',
   format.args=list(big.mark=","),
   caption='Numbers of BEID available in the BED UCB-Human database instance.
   Numbers have been split according to the BE type
   and the organism.
   Only BEID which can be mapped to each other are taken into account
   (i.e. excluding deprecated identifiers without successor).'
)
```

```{r, eval=!reComp}
load("~/Tmp/BEIDs-Stats.rda")
```

```{r, eval=reComp}
## Total number of BEID
nbBeIds <- bedCall(
   cypher,
   query <- prepCql(c(
      'MATCH (n:BEID)',
      #'-[:is_replaced_by|is_associated_to*0..]->(:BEID)-[:identifies]->()',
      'WHERE NOT n.database IN ["BEDTech_gene", "BEDTech_transcript"]',
      'RETURN count(distinct n);'
   ))
)
nbProbeIds <- bedCall(
   cypher,
   query <- prepCql(c(
      'MATCH (n:ProbeID)',
      'RETURN count(distinct n);'
   ))
)
save(
   nbBeIds, nbProbeIds,
   file="~/Tmp/BEIDs-Stats.rda"
)
```

The numbers of biological entity (BE) identifiers (BEID) available in this
BED database instance and which can be mapped to each other are shown
in Table \@ref(tab:ID-Numbers).
In total, `r bigFormat(nbBeIds)` BEID are available in this
BED instance.
This number includes deprecated identifiers without successor and which
therefore cannot be mapped to any other identifier.
All the genomics platforms included in this BED database instance are
shown in Table \@ref(tab:Platforms) . They provide mapping to BEID from
`r bigFormat(nbProbeIds)` ProbeID in total.

```{r Platforms, include=TRUE, results='asis'}
toShow <- listPlatforms()
colnames(toShow) <- c("Name", "Description", "BE")
toShow$Description <- sub(" [(].*$", "", toShow$Description)
kable(
   toShow,
   row.names=FALSE,
   format='pandoc',
   caption='Genomics platforms available in the BED UCB-Human database instance.'
)
```

## Querying the database

The *BED* R package provides functions
to connect to the \neo{} database (`connectToBed`)
and to directly query it (`bedCall`).
Beside these two functions, others of higher level are provided
to explore available data, to manage identifiers
and to convert them from one scope to another.

Different functions can be used to explore the data model
by listing the type of BE (`listBe`)
or describing their relationships (`firstCommonUpstreamBe`).
Available organisms, databases and platforms can also be retrieved using
`listOrganisms`, `listBeIdSources` and `listPlatforms` functions.

All BEIDs of matching a specific scope can be get with the `getBeIds` function.
A specific BEID and its relationships with others can be graphically explored
with the `exploreBe` function.
The use and the results of these two functions are exemplified in Use Cases.
Also, the functions `guessIdOrigin` and `checkBeIds` are used to guess and to
check the scope of any list of identifiers.
This set of functions is completed by the `getBeIdSymbols`and `getBeIdNames`
and `getBeIdDescription` functions which provided different ways to annotate
identifiers taking advantage of information related to connected identifiers.
Other functions are also provided to seek relevant identifiers of a specific
biological entity. These functions are used by a shiny [@chang_shiny:_2017]
gadget providing an interactive dictionary of BEID which is also made
available as an Rstudio add-in [@cheng_miniui:_2016; @allaire_rstudioapi:_2017].

As described above, the BED data model has beeing built to fulfill
molecular biology processes.
The *is_expressed_as* and *is_translated_in* relationships correspond to the transcription  and translation processes respectively
whereas *codes_for* is a fuzzy relationship allowing the mapping
of genes on objects
not necessarily corresonpding to the same kind of biological molecules.
These processes are described in different databases with different
levels of granularity. For exemple, Ensembl [@zerbino_ensembl_2017] provides
possible transcripts for each gene specifying which of them is canonical.
The `getDirectProduct` and `getDirectOrigin` function allow the user
to retrieve direct products or direct origins
of such molecular biology processes.

The automatic conversion of identifiers from one scope to another is handled
by the `convBeIds` function.
This conversion process can be applied directly
on lists of identifiers (`convBeIdLists`)
or on data frames with an identifer column (`convDfBeIds`).
Because such conversion can be intricate, the `exploreConvPath` function
is provided to display the shortest path between two identifiers.
These function are also exemplified in Use Cases.

Converting thousands of identifiers can take some time
(generally a few seconds). Also such conversions are often recurrent and
redundant. In order to improve the performance for such recurrent and redundant
queries, a cache system has been implemented. The first time, the query is run
on \neo{} for all the relevant ID related to user input and the result is saved
in a local file. Next time similar queries are requested, the system does
not call \neo{} but loads the cached results and filters it according
to user input.
By default the cache is flushed when the system detects inconsistencies
with the BED database. It can also be manually flushed
if needed (`lsBEdCache` and `clearBedCache` functions).

## Operation

Minimal system requirements for running BED and neo2R R packages:

- **R** $\geq$ 3.4
- **Operating system**: Linux, macOS, Windows
- **Memory** $\geq$ 4GB RAM

The graph database has been implemented
with \neo{} version 3 [@neo4j_inc_neo4j_2017].
The BED R package depends on the following packages available in the
Comprehensive R Archive Network [@cran_comprehensive_nodate]:

- *visNetwork* [@almende_b.v._visnetwork:_2017]
- *dplyr* [@wickham_dplyr:_2017]
- *htmltools* [@rstudio_inc_htmltools:_2017]
- *DT* [@xie_dt:_2016]
- *shiny* [@chang_shiny:_2017]
- *miniUI* [@cheng_miniui:_2016]
- *rstudioapi* [@allaire_rstudioapi:_2017]


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Use Cases

In addition to those described below,
other use cases and examples are provided in the BED R package vignette.

## Exploring identifiers of biological entities

The `getBeIds` function returns all identifiers from a specific scope.
As described in Methods a scope is defined
by its type (the type of biological entity (BE) or probe),
its source (a database for BE or a platform fro probes)
and the organism to which it refers.
For example, the following code
returns all the Ensembl identifiers of human genes.

```{r include=TRUE, echo=TRUE}
beids <- getBeIds(
    be="Gene", source="Ens_gene", organism="human",
    restricted=FALSE
)
head(beids)
```

```{r}
redUnRestIds <- table(table(beids$Gene))
redUnRestIds <- redUnRestIds[order(as.numeric(names(redUnRestIds)))]
ensVersion <- bedCall(
   cypher,
   query=prepCql(c(
      'MATCH (n:BEDB {name:"Ens_gene"}) RETURN n.currentVersion'
   ))
)
```

```{r beidTables, fig.width=6, fig.height=3, out.width='100%', include=TRUE, fig.cap=sprintf('Barplots showing the number of gene BE (log scale) identified by one or more Ensembl gene BEID. a) All Ensembl gene ID. b) Current Ensembl gene ID (version %s).', ensVersion)}
layout(matrix(c(1,1,1,1,2,2,2), 1, 7, byrow = TRUE))
par(mar=c(5.1, 4.5, 1.1, 0.5))
barplot(
   redUnRestIds,
   xlab="Number of BEID",
   ylab="Number of BE", log="y",
   las=2,
   cex.axis=0.7,
   cex.names=0.7
)
mtext(text="(a)", side=2, line=3, at=10^par()$usr[4], las=2, font=2)
##
rbeids <- getBeIds(
    be="Gene", source="Ens_gene", organism="human",
    restricted = TRUE
)
redIds <- table(table(rbeids$Gene))
redIds <- redIds[order(as.numeric(names(redIds)))]
barplot(
   redIds,
   xlab="Number of BEID",
   ylab="Number of BE", log="y",
   las=2,
   cex.axis=0.7,
   cex.names=0.7
)
mtext(text="(b)", side=2, line=3, at=10^par()$usr[4], las=2, font=2)
```

The *id* column corresponds to the BEID from the source of interest.
The column named according to the BE type (in this case *Gene*)
corresponds to the internal identifiers of the related BE.
This internal identifier is not a stable reference that can be used as such.
Nevertheless, it is useful to identify BEID identifying the
same BE.
In the example above even if most of Gene BE are identified by only
one Ensembl gene BEID, many of them are identified by two or more
(`r bigFormat(sum(redUnRestIds[which(as.numeric(names(redUnRestIds))>=2)]))`
/ `r bigFormat(sum(redUnRestIds))`
= `r round(100*sum(redUnRestIds[which(as.numeric(names(redUnRestIds))>=2)])/sum(redUnRestIds))`&nbsp;%);
`r sum(redUnRestIds[which(as.numeric(names(redUnRestIds))>=10)])` BE
are even identified by more than 10 Ensembl BEID
(Figure \@ref(fig:beidTables).a).
In this case, most of these redundancies come from deprecated ID from former
versions of the Ensembl database (version in use here: `r ensVersion`)
and can be excluded by setting the `restricted` parameter to `TRUE` when calling
the `getBeIds` function (Figure \@ref(fig:beidTables).b).
However many BE are still identified by two or more current Ensembl BEID
(`r bigFormat(sum(redIds[which(as.numeric(names(redIds))>=2)]))`
/ `r bigFormat(sum(redIds))`
= `r round(100*sum(redIds[which(as.numeric(names(redIds))>=2)])/sum(redIds))`~%).
This result comes from the way the BED database is constructed:
When two identifiers from the same resource correspond to the same identifier
in another resource (*correspond_to* relationship in the data model),
all these BEID are considered to identify the same BE.

A complex example of such mapping is shown in Figure \@ref(fig:TAS2R8)
mapping all the BEID of the human TAS2R8 gene which codes for a protein
of the family of candidate taste receptors. There are three identifiers
corresponding to this gene symbol in Ensembl. All these three identifiers
correspond to the same Entrez gene and the same HGNC identifiers.
All these BEID are thus considered to identify the same gene. It turns out
that the three Ensembl BEID correspond to the same gene mapped on different
sequence version of the chromosome 12: the canonical (ENSG00000121314),
CHR_HSCHR12_2_CTG2 (ENSG00000272712)
and CHR_HSCHR12_3_CTG2 (ENSG00000277316).
This information provided by Ensembl is encoded in the *seq_region*
attribute for each Ensembl BEID (see data model)
and is used to define *preferred* BEID which are mapped on canonical version
of chromosome sequences.
The ENSG00000272712 identifier shows also a complex history in former
Ensembl versions.

```{r TAS2R8, include=TRUE, out.width='100%', fig.cap = 'BED relationships between all the different identifiers of the human TAS2R8 gene recorded in the database. BEID are shown as circle and gene symbol in the rounded box. The color legend is shown to the left of the figure. BEID surrounded in bold correspond to \\emph{preferred} identifiers. Solid arrows represent \\emph{correspond\\_to} and \\emph{is\\_known\\_as} relationships. Dotted arrows represent \\emph{is\\_replaced\\_by} and \\emph{is\\_associated\\_to} relationships. This graph has been drawn with the \\texttt{exploreBe} function.'}
include_graphics('img/TAS2R8-Identifiers.png')
```

## Converting gene identifiers

```{r, eval=!reComp}
## Save/load results from commmands below to not recompute everything
load("~/Tmp/ConvTables-3rdTools.rda")
```

The main goal of BED is to convert identifiers from one scope to another
easily, rapidly and with high completeness.
It has been thought in order to allow recurring comparisons to each other of
many lists of biological entities from various origins.

A simple example regarding the conversion of human Ensembl
gene to human Entrez gene identifiers is shown below and discussed hereafter.
By setting the `restricted` parameter to `TRUE` the converted BEID are
restricted to current - non-deprecated - version of Entrez gene identifiers.
Nevertheless all the input BEID are taken into account,
current and deprecated ones.

```{r, include=TRUE, echo=TRUE, eval=reComp}
bedConv <- convBeIds(
   ids=beids$id, from="Gene", from.source="Ens_gene", from.org="human",
   to.source="EntrezGene", restricted=TRUE
)
```

```{r}
curBeid <- unique(beids$id[which(beids$db.deprecated=="FALSE")])
depBeid <- unique(beids$id[which(beids$db.deprecated!="FALSE")])
```

Among all the `r bigFormat(length(curBeid)+ length(depBeid))`
human Ensembl gene identifiers available in the
database, `r bigFormat(sum(is.na(bedConv$to)))`
(`r round(100*sum(is.na(bedConv$to))/length(unique(bedConv$from)))`&nbsp;%)
were not converted to any human Entrez gene
identifier: `r bigFormat(sum(is.na(bedConv$to[which(bedConv$from %in% curBeid)])))`
(`r round(100*sum(is.na(bedConv$to[which(bedConv$from %in% curBeid)]))/length(curBeid))`&nbsp;%)
of the `r bigFormat(length(curBeid))` non-deprecated
and `r bigFormat(sum(is.na(bedConv$to[which(bedConv$from %in% depBeid)])))`
(`r round(100*sum(is.na(bedConv$to[which(bedConv$from %in% depBeid)]))/length(depBeid))`&nbsp;%)
of the `r bigFormat(length(depBeid))` deprecated identifiers.

```{r, eval=reComp}
## biomaRt
library(biomaRt)
bmEnsembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
bmConv <- getBM(
   values = unique(beids$id),
   filters = 'ensembl_gene_id',
   attributes=c('ensembl_gene_id', 'entrezgene'),
   mart = bmEnsembl
)

## mygene
library(mygene)
mgConv <- queryMany(
   qterm=unique(beids$id),
   scopes = "ensembl.gene",
   fields="entrezgene",
   species="human"
)

## gProfileR
library(gProfileR)
gpConv <- gconvert(
   query=unique(beids$id),
   target="ENTREZGENE_ACC",
   organism="hsapiens",
   filter_na=FALSE,
   df=FALSE
)
gpConv <- do.call(
   rbind,
   lapply(
      gpConv,
      function(x){
         data.frame(
            alias=as.character(x[,"alias"]),
            target=as.character(x[,"target"]),
            stringsAsFactors=FALSE
         )
      }
   )
)
gpConv$target <- sub("ENTREZGENE_ACC:", "", gpConv$target)
gpConv$target <- ifelse(gpConv$target=="N/A", NA, gpConv$target)
rownames(gpConv) <- c()
gpConv <- unique(gpConv)
```

```{r, eval=reComp}
evalDate <- Sys.Date()
save(
   bedConv, bmConv, mgConv, gpConv, evalDate,
   file="~/Tmp/ConvTables-3rdTools.rda"
)
```

Three other tools were used on `r format(evalDate, "%b %d, %Y")`
to perform the same conversion task:
biomaRt [@kinsella_ensembl_2011; @durinck_mapping_2009],
mygene [@wu_biogps_2013; @mark_mygene:_2014],
and gProfileR [@reimand_g:profiler-web_2016; @reimand_gprofiler:_2016].
At that time, biomaRt was based on the Ensembl 92 release,
mygene on release 91 and gProfileR on release 90.

```{r}
gq.all <- unique(beids$id)
toComp.all <- list(
   "BED"=unique(bedConv$from[which(!is.na(bedConv$to))]),
   "biomaRt"=unique(bmConv$ensembl_gene_id[which(!is.na(bmConv$entrezgene))]),
   "mygene"=unique(mgConv$query[which(!is.na(mgConv$entrezgene))]),
   "gProfileR"=unique(gpConv$alias[which(!is.na(gpConv$target))])
)
gq.cur <- unique(beids$id[which(beids$db.deprecated=="FALSE")])
toComp.cur <- lapply(
   toComp.all,
   intersect,
   gq.cur
)
```

```{r vennTools, fig.width=10, fig.height=4, out.width='100%', include=TRUE, fig.cap=sprintf('Venn diagrams showing the number of human Ensembl gene identifiers mapped to at least one human Entrez gene identifier by the different tested tools when focusing (a) on all %s or (b) on current %s BEID (Ensembl %s release).', bigFormat(length(gq.all)), bigFormat(length(gq.cur)), ensVersion)}
venn.plot.all <- venn.diagram(
   toComp.all, NULL,
   fill=brewer.pal(4, "Accent"),
   alpha=rep(0.5, 4),
   main="(a)", main.pos=c(0.05,0.95),
   main.fontface=2, main.cex=1.8
)
venn.plot.cur <- venn.diagram(
   toComp.cur, NULL,
   fill=brewer.pal(4, "Accent"),
   alpha=rep(0.5, 4),
   margin=0.1,
   main="(b)", main.pos=c(0.05,0.95),
   main.fontface=2, main.cex=1.8
)
grid.newpage()
grid.arrange(
   gTree(children=venn.plot.all, vp=viewport(width=0.8,height=0.9)),
   gTree(children=venn.plot.cur, vp=viewport(width=0.8,height=0.9)),
   ncol=2
)
```

```{r}
## Exploring mappings only from BED
onlyInBed <- bedConv[
   which(
      !bedConv$from %in% unlist(toComp.all[-1]) &
      !is.na(bedConv$to)
   ),
]
onlyInBedCur <- onlyInBed[
   which(
      onlyInBed$from %in% beids$id[which(beids$db.deprecated=="FALSE")]
   ),
]
onlyInBedDep <- onlyInBed[
   which(onlyInBed$from %in% setdiff(onlyInBed$from, onlyInBedCur$from)),
]
head(onlyInBedDep[order(as.numeric(onlyInBedDep$to)),])
head(onlyInBedCur[order(as.numeric(onlyInBedCur$to)),])
sum(unique(onlyInBedCur$from) %in% beids$id[which(beids$preferred)])
##
fromNcbi <- bedCall(
   cypher,
   query=prepCql(c(
   'MATCH (f:GeneID {database:"Ens_gene"}) WHERE f.value IN $from',
   'MATCH (t:GeneID {database:"EntrezGene"})',
   'MATCH (f)-[:corresponds_to]-(t)',
   'RETURN f.value as from, t.value as to'
)),
   parameters=list(from=as.list(unique(onlyInBedCur$from)))
)
all(
   paste(fromNcbi$from, fromNcbi$to) %in%
      paste(onlyInBedCur$from, onlyInBedCur$to)
)
##
fromHgnc <- bedCall(
   cypher,
   query=prepCql(c(
   'MATCH (f:GeneID {database:"Ens_gene"}) WHERE f.value IN $from',
   'MATCH (i:GeneID {database:"HGNC"})',
   'MATCH (t:GeneID {database:"EntrezGene"})',
   'MATCH (f)-[:corresponds_to]-(i)-[:corresponds_to]-(t)',
   'RETURN f.value as from, t.value as to'
)),
   parameters=list(from=as.list(setdiff(onlyInBedCur$from, fromNcbi$from)))
)
##
remaining <- setdiff(
   onlyInBedCur$from, c(fromHgnc$from, fromNcbi$from)
)
```

```{r}
## Numbers from venn diagram
onlyInGp <- setdiff(
   toComp.all$gProfileR,
   unlist(toComp.all[which(names(toComp.all)!="gProfileR")])
)
onlyInGp.l <- length(onlyInGp)
onlyInMg <- setdiff(
   toComp.all$mygene,
   unlist(toComp.all[which(names(toComp.all)!="mygene")])
)
onlyInMg.l <- length(onlyInMg)
onlyInGpAndMg <- setdiff(
   intersect(toComp.all$gProfileR, toComp.all$mygene),
   unlist(toComp.all[which(!names(toComp.all) %in% c("gProfileR", "mygene"))])
)
onlyInGpAndMg.l <- length(onlyInGpAndMg)
##
onlyInBedAndBm <- setdiff(
   intersect( toComp.all$BED, toComp.all$biomaRt),
   unlist(toComp.all[which(!names(toComp.all) %in% c("BED", "biomaRt"))])
)
onlyInBedAndBm.l <- length(onlyInBedAndBm)
```


The numbers of human Ensembl gene identifiers successfully converted by each
method are compared in Figure \@ref(fig:vennTools).
Mappings returned only by gProfileR or by mygene
(`r onlyInGp.l` + `r onlyInMg.l` + `r onlyInGpAndMg.l`)
are available in releases
90 and 91 of Ensembl respectively but not in release 92.
Similarly mappings returned by both BED and biomaRt but neither by gProfileR
nor mygene
(`r onlyInBedAndBm.l`)
are available in release 92 of Ensembl but not in releases 91 or 90.
All the gene identifiers successfully converted by biomaRt were also
converted by BED.
However, BED was able to map at least
`r bigFormat(length(unique(onlyInBed$from)))` more identifiers than all the
other tools (Figure \@ref(fig:vennTools).a). A few of these mappings
(`r bigFormat(length(unique(onlyInBedDep$from)))`)
are explained by the fact that BED is the only tool mapping
deprecated identifiers to current versions.
Nevertheless, even when focusing on the mapping of current versions of
Ensembl identifiers BED was able to
map `r bigFormat(length(unique(onlyInBedCur$from)))`
more identifiers than all the
other tools (Figure \@ref(fig:vennTools).b).
A few of these mappings (`r bigFormat(length(unique(fromNcbi$from)))`)
are directly provided by the NCBI. But most of them
(`r bigFormat(length(unique(fromHgnc$from)))`)
are inferred from a mapping of the Ensembl and Entrez gene identifiers
to the same HGNC [@gray_genenames.org:_2015] identifier.

```{r}
## Gene locations
load("~/Tmp/gene-locations.rda")
mappings <- list()
## Reference
toAdd <- unique(bmConv[which(
   bmConv$ensembl_gene_id %in% intersect(
      intersect(toComp.all$BED, toComp.all$biomaRt),
      intersect(toComp.all$mygene, toComp.all$gProfileR)
   )
),])
colnames(toAdd) <- c("ensembl", "entrez")
toAdd$ensembl <- as.character(toAdd$ensembl)
toAdd$entrez <- as.character(toAdd$entrez)
toAdd <- toAdd[which(
      toAdd$ensembl %in% ensemblGenes$gene &
         toAdd$entrez %in% entrezGenes$gene
),]
toAdd <- cbind(
   cbind(toAdd, ensemblGenes[toAdd$ensembl,c("chromosome", "start", "stop")]),
   entrezGenes[toAdd$entrez,c("chromosome", "start", "stop")]
)
colnames(toAdd) <- c(
   "ensembl", "entrez",
   "chr.ens", "start.ens", "stop.ens",
   "chr.ncbi", "start.ncbi", "stop.ncbi"
)
mappings$"Reference" <- toAdd
## Former
toAdd <- unique(as.data.frame(mgConv[which(
   mgConv$query %in% setdiff(
      toComp.all$mygene,
      unlist(toComp.all[c("BED", "biomaRt")])
   )
), c("query", "entrezgene")]))
colnames(toAdd) <- c("ensembl", "entrez")
toAdd$ensembl <- as.character(toAdd$ensembl)
toAdd$entrez <- as.character(toAdd$entrez)
toAdd <- toAdd[which(
      toAdd$ensembl %in% ensemblGenes$gene &
         toAdd$entrez %in% entrezGenes$gene
),]
toAdd <- cbind(
   cbind(toAdd, ensemblGenes[toAdd$ensembl,c("chromosome", "start", "stop")]),
   entrezGenes[toAdd$entrez,c("chromosome", "start", "stop")]
)
colnames(toAdd) <- c(
   "ensembl", "entrez",
   "chr.ens", "start.ens", "stop.ens",
   "chr.ncbi", "start.ncbi", "stop.ncbi"
)
mappings$"Former" <- toAdd
##
toAdd <- unique(bedConv[which(
   bedConv$from %in% setdiff(
      toComp.cur$BED,
      unlist(toComp.cur[c("biomaRt", "mygene", "gProfileR")])
   )
), c("from", "to")])
colnames(toAdd) <- c("ensembl", "entrez")
toAdd$ensembl <- as.character(toAdd$ensembl)
toAdd$entrez <- as.character(toAdd$entrez)
toAdd <- toAdd[which(
      toAdd$ensembl %in% ensemblGenes$gene &
         toAdd$entrez %in% entrezGenes$gene
),]
toAdd <- cbind(
   cbind(toAdd, ensemblGenes[toAdd$ensembl,c("chromosome", "start", "stop")]),
   entrezGenes[toAdd$entrez,c("chromosome", "start", "stop")]
)
colnames(toAdd) <- c(
   "ensembl", "entrez",
   "chr.ens", "start.ens", "stop.ens",
   "chr.ncbi", "start.ncbi", "stop.ncbi"
)
mappings$"BED" <- toAdd
```

We assessed the validity of the mappings by comparing the location on the human
genome (GRCh38) of Ensembl gene identifiers as reported by Ensembl
and the location of the corresponding Entrez gene identifiers
as reported by the NCBI. If the mapping between two identifiers is correct
their location on the genome should be identical or higly similar.
Only gene identifiers located on on canonical version
of chromosome sequences were considered for this comparison.
We compared the following mappings:

   - Reference (n = `r nrow(mappings$"Reference")`): the mappings provided
   by biomaRt for identifiers successfully converted by all the tools.
   
   - Former (n = `r nrow(mappings$"Former")`): the mappings
   provided by mygene for identifers
   successfully converted by mygene but neither by biomaRt nor BED.
   
   - BED (n = `r nrow(mappings$"BED")`): the mappings
   provided by BED for identifers
   successfully converted by BED but not by any of the 3 other tools.
   
```{r}
par(
   mfrow=c(1,3),
   mar=c(4.1, 4.5, 1.1, 0.5)
)
## Chromosomes
toPlot <- unlist(lapply(
   mappings,
   function(d){
      sum(d$chr.ens!=d$chr.ncbi)/nrow(d)
   }
))
bp <- barplot(
   toPlot*100,
   ylab=expression("" != "chromosomes (%)"),
   beside=TRUE
)
text(
   bp, 1,
   paste(signif(toPlot*100,2), "%"),
   pos=3
)
mtext(text="(a)", side=2, line=3, at=par()$usr[4], las=2, font=2)
## Starts
toPlot <- lapply(
   mappings,
   function(d){
      d <- d[which(d$chr.ens==d$chr.ncbi),]
      abs(d$start.ens-d$start.ncbi)
   }
)
bp <- boxplot(
   toPlot[1:2],
   col="grey",
   outline=FALSE,
   ylab=expression(group("|", Delta(start), "|"))
)
text(
   2, bp$stats[3,2], round(bp$stats[3,2]),
   pos=3
)
text(
   2, bp$stats[4,2], round(bp$stats[4,2]),
   pos=3
)
mtext(text="(b)", side=2, line=3, at=par()$usr[4], las=2, font=2)
bp <- boxplot(
   toPlot[c(1,3)],
   col="grey",
   outline=FALSE,
   ylab=expression(group("|", Delta(start), "|"))
)
text(
   1:2, bp$stats[3,], round(bp$stats[3,]),
   pos=3
)
text(
   1:2, bp$stats[4,], round(bp$stats[4,]),
   pos=3
)
mtext(text="(c)", side=2, line=3, at=par()$usr[4], las=2, font=2)
```

<!-- TODO -->
## Transitivity and mapping rules

The BED `convBeIds` function can be used to convert identifiers from
any available scope to any other one. It automatically find the most
relevant path according to the considered biological entities.
It allows elaborate mapping such as the conversion between
probe identifiers from a platform focused on mouse transcripts into
human protein identifiers.
Because such mappings can be intricate,
BED also provides a function to show the shortest relevant path between
two different identifiers (Figure \@ref(fig:explConv)).

```{r explConv, include=TRUE, out.width='100%', fig.cap = 'BED conversion shortest path between the ILMN\\_1220595 probe identifier targeting a transcript of the mouse Il17a gene and the Uniprot Q16552 identifier of the human IL17 protein. The legend is shown to the left of the figure. The red arrow represents the \\emph{is\\_homolog\\_of} relationship. This graph has been drawn with the \\texttt{exploreConvPath} function.'}
include_graphics('img/ILMN_1220595-Conversion.png')
```

<!-- TODO -->
## Comparing transcriptomics results from different experimental design

<!-- TODO -->
## Performance


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Conclusions

BED is a system dedicated to the mapping between identifiers of molecular
biological entities. It relies on a graph data model implemented with
\neo{} and on rules coded in an R package.
BED leverages mapping information provided by different resources in order
to increase the mapping efficiency between each of them.
It also allows the mapping of deprecated identifiers.
Rules are used to automatically convert identifiers from one scope to another
using the most appropriate path.

The intend of BED is to be tailored to specific needs and
beside functions for querying the system the BED R package provides functions
to build custom instances of the database.
Database instances can be localy installed or shared accross a community.
This design combined with a cache system makes BED performant for converting
large lists of identifiers from and to a large variety of scopes.

Because of our research field we provide an instance focused on human,
mouse and rat organisms. This database instance can be directly used
in relevant projects but it can also be enriched depending on user or
community needs.

<!-- TODO -->
<!-- BED usage contexts -->

<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Software availability

Latest source code is available at:

https://github.com/patzaw/BED

https://github.com/patzaw/neo2R

Archived source code as at time of publication:

<!---------->
<!-- TODO -->
<!-- Add BED and neo2R doi in bibliography -->

https://zenodo.org/badge/latestdoi/<!--DOI??--> <!-- (Godard, 2018a) -->
https://zenodo.org/badge/latestdoi/<!--DOI??--> <!-- (Godard, 2018b) -->

Software is available to use under a GPL-3 license


<!----------------------------------------------------------------------------->
<!----------------------------------------------------------------------------->
# Competing interests

No competing interests were disclosed.

# Grant information

This work was entirely supported by UCB Pharma.
The authors declared that no grants were involved in supporting this work.

# Acknowledgments

We are grateful to Frédéric Vanclef, Malte Lucken, Liesbeth François,
Matthew Page,
Massimo de Francesco, and Marina Bessarabova for fruitful discussions
and constructive criticisms.

